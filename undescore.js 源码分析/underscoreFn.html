<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
</head>
<body>
<div id="odiv">
	<p class="para"></p>
	<p class="para"></p>
</div>
<script src="./thescore.js"></script>
<script>
  window.onload = function () {
		let list = [1, 2, 3];
		function filter(memo, value) {
			return memo * value ;
		}
		_.map(list, filter)

	function map(obj, iteratee, context) {
		if (obj === null) return [];
		var keys = obj.length !== +obj.length && Object.keys(obj),
				length = (keys || obj).length,
				results = Array(length),
				currentIndex;
		for(var index = 0; index < length; index++) {
			currentIndex = keys ? keys[index] : index;
			results[index] = iteratee(obj[currentIndex], currentIndex, obj);
		}
		return results;
	}
	function reduce(obj, iteratee, memo, context) {
		if (obj === null) obj = [];
		var keys = obj.length !== +obj.length && Object.keys(),
				length = (keys || obj).length,
				index = 0, currentIndex;
		if (arguments.length < 3) {
			memo = obj[keys ? keys[index++] : index++];
		}
		for (; index < length; index++) {
			currentIndex = keys ? keys[index] : index;
			memo = iteratee(memo, obj[currentIndex], currentIndex, obj);
		}
		return memo;
	}
	function contact(a, b) {
		return a.concat(b);
	}
	list = [[1, 2], [3, 4], [5, 6]];
	function reduceRight(obj, iteratee, memo, context) {
		if (obj === null) return [];
		var keys = obj.length !== +obj.length && Object.keys(obj),
				index = (keys || obj).length,
				currentIndex;
		if (arguments.length < 3) {
			memo = obj[keys ? keys[--index] : --index];
		}
		while(index-- > 0) {
			currentIndex = keys ? keys[index] : index;
			memo = iteratee(memo, obj[currentIndex], currentIndex, obj);
		}
		return memo;
	}
	list = [1, 2, 4];
	function getOdd(num) {
		return num % 2 === 0;
	}
	function findIndex(array, predicate) {
		var length = !array ? 0 : array.length;
		for (let i = 0; i < length; i++) {
			if (predicate(array[i], i, array)) return i;
		}
		return -1;
	}
	function find(obj, predicate) {
		var key;
		// 对象
		if (obj.length !== +obj.length) {
			key = findKey(obj, predicate);
		} else {
			key = findIndex(obj, predicate);
		}
		if (key !== void 0 && key !== -1) return obj[key]; 
	}
	list = [1, 2, 5, 6];
	function toFilter(num) {
		return num % 2 === 0;
	}
	function filter(obj, predicate, context) {
		let results = [];
		if (obj == null) {
			return results;
		}
		_.each(obj, function(value, index, list) {
			if (predicate(value)) {
				results.push(value);
			}
		})
		return results;
	}
	list = [{name: '张宁宁', age: 18}, {name: '张宁宁', age: 70}];
	function where(list, sObj) {
		let results = [];
		let flag = false;
		if (list == null) {
			return results;
		}
		for (let obj of list) {
			for (let key in obj) {
				if (Object.keys(sObj).includes(key)) {
					if (sObj[key] === obj[key]) {
						flag = true;
					} else {
						flag = false;
					}
				} else {
					flag = false;
				}
			}
			if (flag) {
				results.push(obj);
			}
		}
		return results;
  }
  function name() {
    return function(name) {
			console.log(name);
    }
  }
  function container(obj, value, fromIndex) {
    if (obj == null) return false;
    let length = obj.length;
    let index = fromIndex || 0;
    if (obj.indexOf(value) >= 0) {
      return true;
    }
    return false;
  }
  list = [1, 2, 3];
	}
	list = [4, 4, 4, 4];
	function rejectFn (num) {
		return num % 2 === 0;
	}
	// 如果obj 中的对象都通过 predicate 函数的真值检验那么返回为true
	function every(obj, predicate) {
		if (obj == null) return true;
		let keys = obj.length == +obj.length && Object.keys(obj);
		let currentKey;
		let length = (keys || obj).length;
		for (let index = 0; index < length; index++) {
			currentKey = keys ? keys[index] : index;
			if (!predicate(obj[currentKey])) return false;
		}
		return true;
	}
	function contain(obj, value, fromIndex) {
  if (obj == null) return false;
  let list = obj;
  if (obj.length !== +obj.length) {
    list = obj.values();
	}
	console.log(list.indexOf(value));
  return list.indexOf(value, fromIndex) >= 0;
}
 console.log(contain([1, 2, 3], 2, 'fds'));
 function get(value) {
	 console.log(this);
	 console.log('得到的值', this);
	 console.log(value);
 }
 list = [[1, 2]];
 function pluck(list, name) {
	 let props = [];
	 list.map((obj) => {
		 if (Object.keys(obj).indexOf(name) >= 0) {
			 props.push(obj[name]);
		 } else {
			 props.push(void 0);
		 }
	 });
	 return props;
 }
 let a = [{a: 1}, {b: 2}, {a: '张艺苇'}];
 console.log(pluck(a, 'a'));
 // underscore.js max 函数
 var list = [{name: '张宁宁ds', age: 12}, {name: '张艺苇', age: 40}, {name: '张艺苇', age: 50}];
 function getMax(value) {
   return value.name.length;
 }
 list = [1, 2, 4];
 list = [{name: '张宁宁', age: 20}, {name: '张宁宁', age: 50}];
 function group(behavior) {
	 return function (list, iteratee, context) {
		 let result = {};
		 _.each(list, function(value, index) {
			 var key = iteratee(value, index, obj);
			 behavior(result, value, key);
		 })
		 return result;
	 }
 }
let groupBy = group(function(result, value, key) {
	result[key] = value;
});
let obj = [1, 2, 4];
let result = groupBy(obj, function(num) {
	return num % 2;
});
console.log('得到的计算result', result);

let countBy = group(function(result, value, key) {
	if (_.has(result, key)) result[key] ++; else result[key] = 1;
});
console.log('得到的计数值', countBy(obj, function(num) {
	return num % 2;
}));
list = [1, 2, 3, 4, 5, 6];
console.log(_.shuffle(list));
let arrLikeObj = document.getElementsByTagName('p');
console.log('长度', arrLikeObj.length);
console.log('类数组对象的类型', Object.prototype.toString.call(arrLikeObj));
console.log('类数组对象', document.getElementsByTagName('p'));
// 如何将一个嵌套多层的数组转化为一层的数组？
list = [1, [3, 4]];
console.log('得到去除掉多层嵌套的数组', _.flatten(list));

function without(array, values) {
  if (typeof values === 'undefined') return array;
  if (array && array.length) {
		let value = Array.prototype.slice.call(arguments, 1);
    let newArray = array.filter((item) => {
      return value.indexOf(item) === -1;
		});
		return newArray;
  } else {
    return [];
  }
}
console.log('得到的without函数', without([1, 3, 4], 1));
function without(array, value) {
  console.log('ars', arguments);
  let a = Array.prototype.slice.call(arguments, 1);
  let rest = array.filter((item) => {
    // 这里需要返回一个值
    return a.indexOf(item) == -1;
  });
}
without([1, 2, 3], 1, 2);

// union 使用 union 用来返回一个数组的并集
console.log(_.intersection([1, 2, 2, 3], [2, 3, 4]));
function difference(array, other) {
	let rest = Array.prototype.slice.call(arguments, 1);
	let newArr = array.filter((item) => {
		return other.indexOf(item) === -1;
	});
	return newArr;
}
console.log(difference([1, 2, 3], [3, 4]));
function bubbleSort (arr) {
let len = arr.length;
  for (let i = 0; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
    // 比较相邻两个的大小, 将较大的那个排到后面去
    // 始终保证
      if (arr[j] < arr[i]) {
        // 使用 es6 结构赋值进行交换
				let t = arr[j];
				arr[j] = arr[i];
				arr[i] = t;
      }
    }
  }
}
let s = [1, 3, 5 ,2 ,7, 4];
// 快速排序
function quickSort(arr) {
	if (arr.length <= 1) {
		return arr;
	}
	let len = arr.length;
	let rightArr = [];
	let leftArr = [];
	let first = arr[0];
	for (let i = 0; i < len; i++) {
		if (arr[i] < first) {
			leftArr.push(arr[i]);
		}
		if (arr[i] > first) {
			rightArr.push(arr[i]);
		}
	}
	return [].concat(quickSort(leftArr), [first], quickSort(rightArr));
}
// 使用 concat 用于返回数组的拼接
console.log('得到的数组', quickSort([1, 4, 2, 6, 3]));

/** 
 * @description 用于合成数组
 * @param {Object} array 传入的多个数组
 * @return {Object} 返回的经过合成之后的数组
*/
function zip(array) {
	let args = Array.prototype.slice.call(arguments, 0);
	let f = array;
	let result = [];
	console.log('获得到的数组', array, args);
	array.map((item, index) => {
		let arr = [];
		args.map((argItem) => {
			arr.push(argItem[index]);
		})
		result.push(arr);
	});
	return result;
}
// 进行插入排序
function chaSort(array) {
	for (let i = 1; i < array.length; i++) {
		let temp = array[i];
		for (let j = i - 1; j >= 0 ; j--) {
			if (array[j] > temp) {
				array[j + 1] = array[j];
				array[j] = temp;
			}
		}
	}
}
let chaList = [1, 4, 7, 2, 3];
chaSort(chaList);
// 使用 unzip 进行解析数组
// function unzip(array) {
//   let ix = 0;
// 	if (array === null) return [];
//   let arr = [];
// 	array.map((items, arrIndex) => {
// 		arr.push(items[ix]);
// 	});
// 	return arr;
// }

function unzip(array) {
	return zip.apply(null, array);
}
console.log(unzip([['张宁宁', '山东'], ['张艺苇', '河北']]));

/**
 * @param {Array} list 键数组
 * @param {Array} values 值数组
 * @description {Object} 组成的对象
*/
function toObj(list, values) {
	if (list === null) return {};
	let obj = {};
	if (typeof values === 'undefined') {
		console.log('list', list);
		list.map((item) => {
			obj[item[0]] = item[1];
		});
	} else {
		list.map((item, index) => {
			obj[item] = values[index];
		})
	}
	return obj;
}
console.log('使用二分法获得到数组中元素的位置', _.sortedIndex([10, 20, 30, 40, 50], 35));

function getMaxProfit(arr) {
	let minProfit = arr[0];
	let maxProfit = 0;
	for (let i = 0; i < arr.length; i++) {
		minProfit = Math.min(minProfit, arr[i]);
		let currentProfit = arr[i] - minProfit;
		maxProfit = Math.max(maxProfit, currentProfit);
	}
	return maxProfit;
}
console.log(getMaxProfit([1, 2, 3, 4]));
function clone(obj) {
  if (obj && typeof obj === 'object') {
		let cloneObj = Object.prototype.toString.call(obj).slice(8, -1) === 'Array' ? [] : {};
    for (let prop in obj) {
      if (obj[prop] && typeof obj[prop] === 'object') {
        cloneObj[prop] = clone(obj[prop]);
      } else {
				cloneObj[prop] = obj[prop];
				console.log('得到的属性', prop, cloneObj);
      }
		}
		return cloneObj;
  } else {
    return obj;
  }
}
function getClass(parent, sClass) {
  let eles = parent.getElementsByTagName('*');
  let eleResult = [];
  let index = 0;
	let eleRe = new RegExp('\\b' + sClass + '\\b', 'i');
  for (let i = 0; i < eles.length; i++) {
    if (eleRe.test(eles[i].className)) {
      eleResult.push(eles[i]);
    }
  }
  return eleResult;
}
console.log('得到的数组', getClass(document.getElementById('odiv'), 'para'));
function quickSort(arr) {
	if (arr.length <= 1) {
		return arr;
	}
	let leftArr = [];
	let rightArr = [];
	let first = arr[0];
	for (let i = 0; i < arr.length; i++) {
		if (arr[i] < first) {
			leftArr.push(arr[i]);
		} else if (arr[i] > first) {
			rightArr.push(arr[i]);
		}
	}
	return [].concat(quickSort(leftArr), [first], quickSort(rightArr));
}
console.log('快速排序', quickSort([1, 3, 4, 5,2, 2]));

// 使用 _.uniq 用于返回数组去重之后的结果

// 一种更有趣的去重算法
// 获得到的是已经被排序的数组
function fillCF(arr) {
  let seen = [];
  let result = [];
  arr.sort();
for (let i = 0; i < arr.length; i++) {
  let value = arr[i];
  let computed = value;
  if (!i || seen !== computed ) result.push(value);
  seen = computed; 
  }
  return result;
}

list = ['zhang', 'zhang', 'ning'];
console.log(fillCF(list));

function range(start, stop, step) {
	let args = arguments;
	let resultArray = [];
	let theStep = 1;
	let theStart = 0;
	if (args.length === 1) {
		stop = args[0];
	}
	if (args.length === 2) {
		theStart = args[0];
		stop = args[1];
	}
	if (args.length === 3) {
		theStart = args[0];
		stop = args[1];
		theStep = args[2];
	}
	if (theStart < stop) {
		for (let index = theStart; index < stop; index = index + theStep) {
		  resultArray.push(index);
	  }
	 } else {
		for (let index = theStart; index > stop; index = index + theStep) {
		resultArray.push(index);
	 }
	}
	return resultArray;
}
console.log('range对象', range(5));

console.log('传入的参数是一个的时候', range(0, 7, 2));
console.log('当我们传入两个参数的时候', range(0, -10, -1));

function range(start, stop, step) {
	if (arguments.length <= 1) {
		stop = start || 0;
		start = 0;
	}
	step = step || 1;
	// 通过使用 Math.max 获取到最大值
	let length = Math.max(Math.ceil((start - stop) / step), 0);
	// 通过使用 new Array 进行创建数组
	let result = new Array(length);
	for (let index = 0; index < length; index++, start += step) {
		result[index] = start;
	}
	return result;
}
function greeting(home) {
	console.log(`hi, my name is ${this.name}, my home is ${home}`);
}

function objProto() {
}
let newObj = Object.create(objProto.prototype);
console.log('新的对象是否属于 objProto 的原型', newObj instanceof objProto);

function getName() {
	console.log('name', this.name);
}

let bindName = _.bind(getName, { name: '张宁宁' });
bindName();
// 使用 partical 函数 实现占位

function add(a, b) {
  console.log('yeeeeeeeeeeeeeeeeee');
  console.log(a + b);
}

function partical(fn) {
  let particalArgs = Array.prototype.slice.call(arguments, 1);
  return function(args) {
		let fnArgs = Array.prototype.slice.call(arguments, 0);
		console.log('得到的数组', particalArgs, args);
    fn(...particalArgs, ...fnArgs);
  }
}

let particalFn = partical(add, 9);

function delay(func, wait) {
  let args = Array.prototype.slice.call(arguments, );
  return setTimeout(function () {
    func.apply(null, args);
  }, wait)
}
// 下面是 throttle 节流函数
// throttle 函数不会等待

function throttle (func, wait, options) {
  let context, args, result;
  let timeout = null;
  let previous = 0;
  if (!options) options = {};
  let later = function () {
    // 如何实现的禁用第一次的调用 ?
    previous = options.leading === false ? 0 : now();
    timout = null;
    // 调用 func 传入 args 参数
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  }
}

function toConcel () {
  console.log('打印出来的东西');
}

let throttleFn =  _.throttle(toConcel, 2000);
throttleFn();

function throttle (func, wait, options) {
  let context, args, result;
  let timeout = null;
  let previous = 0;
  if (!options) options = {};
  let later = function () {
    // 记录下当前的时间
    previous = options.leading === false ? 0 : now();
    // 执行函数之后将 timeout contxt args 重置为 null
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null; 
  };
  return function () {
    let now = now();
    // options.leading === false, 表示禁用第一次执行
    if (!previous && options.leading === false) previous = now;
    // previous 用于是调用显示的时间
    let remainding = wait - (now - previous);
    context = this;
    args = arguments;
    // 如果超过世间间隔
    // 或者 now - previous > 0
    // 保证第一次的时候执行函数, 或者当 now - previous > remainding
    if (remainding <= 0 || remainding > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      // 使用 func.apply 应用函数
      result = func.apply(context, args);
      if (!timeout) context = args = null; 
    } else if (!timeout && options.trailing !== false) {
      // 间隔  remaining 之后调用 later
      timeout = setTimeout(later, remaining);
    }
    return result;
  }
}

function keys (obj) {
  if (!obj && typeof obj !== 'object') return [];
  if (Object.keys) return Object.keys(obj);
  let keys = [];
  for (let key in obj) {
    keys.push(key);
  }
  return keys;
}

person = {
  name: '张宁宁',
  home: '山东',
  age: 20
}

console.log(keys());


</script>
</body>
</html>